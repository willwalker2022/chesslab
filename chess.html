<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chess Fun Labs - Stockfish Integrated</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet" />
  <script src="https://unpkg.com/@phosphor-icons/web"></script>
  <link rel="icon" href="assets/pieces/wk.svg" type="image/svg+xml" />
  <!-- æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨çš„æ˜¯ 0.10.3 ç‰ˆæœ¬ï¼Œå®ƒçš„ API æ˜¯ game_over() è€Œä¸æ˜¯ isGameOver() -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { margin: 0; font-family: 'Nunito', sans-serif; }
    #root { min-height: 100vh; }
    /* Custom Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #f1f1f1; }
    ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
  </style>
</head>
<body class="bg-[#fdfdfd]">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // --- Piece assets (Lichess Alpha set) ---
    const getPieceImg = (color, type) => {
      // Use local sprites to avoid CDN dependency
      const assetPath = `assets/pieces/${color}${type}.svg`;
      return { assetPath };
    };

    // --- Sound Logic ---
    const playMoveSound = () => {
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.15);
      } catch (e) {
        // Silent fail
      }
    };

    // --- Engine (Stockfish) Logic FIXED ---
    const ENGINE_LEVELS = {
      "800": { skill: 0, movetime: 200 },    // Beginner
      "1200": { skill: 5, movetime: 500 },   // Novice
      "1600": { skill: 10, movetime: 800 },  // Intermediate
      "2000": { skill: 15, movetime: 1200 }, // Advanced
      "2500": { skill: 20, movetime: 2000 }  // Grandmaster
    };

    // Robust Engine Client using Blob URL
    const STOCKFISH_SOURCES = [
      { url: 'assets/stockfish.js', label: 'local assets/stockfish.js' }, // place built stockfish.js here for offline use
      { url: 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.0/stockfish.js', label: 'cdnjs fallback' }
    ];

    const fetchEngineScript = async () => {
      let lastError = null;
      for (const src of STOCKFISH_SOURCES) {
        try {
          const response = await fetch(src.url);
          if (!response.ok) throw new Error(`status ${response.status}`);
          const scriptContent = await response.text();
          return { scriptContent, source: src.label };
        } catch (err) {
          lastError = err;
          console.warn(`Engine load failed from ${src.label}: ${err.message}`);
        }
      }
      throw lastError || new Error('Stockfish load failed from all sources');
    };

    const createEngineClient = (onError, onLog, onEval) => {
      let worker = null;
      let resolver = null; // Promise resolver for 'bestmove'
      let isThinking = false;

      // Initialize the worker from CDN via Blob to bypass CORS restrictions
      const init = async () => {
        try {
          const { scriptContent, source } = await fetchEngineScript();
          const blob = new Blob([scriptContent], { type: 'application/javascript' });
          const objectURL = URL.createObjectURL(blob);
          
          worker = new Worker(objectURL);

          worker.onmessage = (event) => {
            const line = typeof event.data === 'string' ? event.data : '';
            if (onLog && line) onLog(line);

            // Parse Evaluation
            if (line.startsWith('info') && onEval && (line.includes('score cp') || line.includes('score mate'))) {
              let score = 0;
              let type = 'cp';
              
              if (line.includes('score mate')) {
                type = 'mate';
                const match = line.match(/score mate (-?\d+)/);
                if (match) score = parseInt(match[1]);
              } else if (line.includes('score cp')) {
                const match = line.match(/score cp (-?\d+)/);
                if (match) score = parseInt(match[1]);
              }
              // Note: Stockfish reports score from engine's perspective
              onEval({ type, value: score });
            }

            // Parse Best Move
            if (line.startsWith('bestmove')) {
              const parts = line.split(' ');
              const bestMove = parts[1];
              isThinking = false;
              if (resolver) {
                resolver(bestMove);
                resolver = null;
              }
            }
          };

          worker.onerror = (err) => {
            console.error("Worker Error:", err);
            if (onError) onError(err.message || "Engine Worker Error");
          };

          worker.postMessage('uci');
          worker.postMessage('isready');
          console.log(`Engine: Initialized via Blob (${source})`);
        } catch (err) {
          console.error("Engine Init Failed:", err);
          if (onError) onError(err.message);
          throw err;
        }
      };

      // Execute a move search
      const go = ({ fen, level, movetimeOverride }) => {
        return new Promise((resolve) => {
          if (!worker) {
            resolve(null);
            return;
          }
          
          // Clear any previous resolver to prevent hanging promises
          if (resolver) resolver(null);
          resolver = resolve;
          isThinking = true;

          // Configure
          const skill = level ? level.skill : 10;
          const time = movetimeOverride || (level ? level.movetime : 1000);

          worker.postMessage('stop'); // Stop any previous
          worker.postMessage('ucinewgame');
          worker.postMessage(`setoption name Skill Level value ${skill}`);
          worker.postMessage(`position fen ${fen}`);
          worker.postMessage(`go movetime ${time}`);
        });
      };

      // Quick search for hints/eval
      const search = ({ fen, depth, time }) => {
        return new Promise((resolve) => {
           if (!worker) { resolve(null); return; }
           
           if (resolver) resolver(null); // Cancel main search if checking hint? 
           // Ideally hints use a separate instance or we manage queue, but for simple app, we override.
           resolver = resolve;
           
           worker.postMessage(`position fen ${fen}`);
           if (time) {
             worker.postMessage(`go movetime ${time}`);
           } else {
             worker.postMessage(`go depth ${depth || 10}`);
           }
        });
      };

      const stop = () => {
        if (worker) worker.postMessage('stop');
      };

      const terminate = () => {
        if (worker) worker.terminate();
        worker = null;
      };

      return { init, go, search, stop, terminate };
    };

    // --- Puzzles Data ---
    const PUZZLES = [
      {
        id: 1,
        fen: "8/8/3k4/8/3K2R1/7P/8/8 w - - 0 1",
        solution: [
            { move: "g4g6", reply: "d6e7" },
            { move: "d4e5" }
        ],
        title: "å¢å¡çº³æ¡¥æ³•",
        description: "ç™½æ–¹å…ˆè¡Œã€‚è½¦é€€èº«å«æ¡¥æŠ¤å…µï¼ˆé¢„è®¾é»‘ç‹ Ke7ï¼‰ã€‚",
        difficulty: "ä¸­ç­‰"
      },
      {
        id: 2,
        fen: "4r1k1/pp3ppp/2n2q2/2b1p3/4P3/2N2N2/PPP2PPP/2KR1B1R w - - 0 1",
        solution: [
            { move: "c3d5", reply: "f6d8" },
            { move: "f1b5" }
        ],
        title: "éª‘å£«å…ˆæ‰‹",
        description: "ç™½æ–¹å…ˆè¡Œã€‚è·³é©¬å…ˆæ‰‹é€¼é€€çš‡åï¼Œå†å‡ºè½¦å‹åˆ¶ã€‚",
        difficulty: "ä¸­ç­‰"
      },
      {
        id: 3,
        fen: "6k1/5ppp/8/8/8/8/5PPP/4Q1K1 w - - 0 1",
        solution: [{ move: "e1e8" }],
        title: "åº•çº¿ç»ˆç»“",
        description: "ç™½æ–¹å…ˆè¡Œã€‚æ”¶å°¾ä¸€å‡»ï¼ˆå•æ­¥ï¼‰ã€‚",
        difficulty: "ç®€å•"
      },
      {
        id: "00008",
        fen: "r6k/pp2r2p/4Rp1Q/3p4/8/1N1P2R1/PqP2bPP/7K b - - 0 24",
        solution: [
          { move: "f2g3", reply: "e6e7" },
          { move: "b2b1", reply: "b3c1" },
          { move: "b1c1", reply: "h6c1" }
        ],
        title: "Lichess å¼€æºè°œé¢˜ 00008",
        description: "ä¸»é¢˜ï¼šcrushing, hangingPiece, long, middlegameï¼›é¢„æœŸ 3 æ‰‹ã€‚",
        difficulty: "ä¸­ç­‰"
      },
      {
        id: "0000D",
        fen: "5rk1/1p3ppp/pq3b2/8/8/1P1Q1N2/P4PPP/3R2K1 w - - 2 27",
        solution: [
          { move: "d3d6", reply: "f8d8" },
          { move: "d6d8", reply: "f6d8" }
        ],
        title: "Lichess å¼€æºè°œé¢˜ 0000D",
        description: "ä¸»é¢˜ï¼šadvantage, endgame, shortï¼›é¢„æœŸ 2 æ‰‹ã€‚",
        difficulty: "ä¸­ç­‰"
      },
      {
        id: "0008Q",
        fen: "8/4R3/1p2P3/p4r2/P6p/1P3Pk1/4K3/8 w - - 1 64",
        solution: [
          { move: "e7f7", reply: "f5e5" },
          { move: "e2f1", reply: "e5e6" }
        ],
        title: "Lichess å¼€æºè°œé¢˜ 0008Q",
        description: "ä¸»é¢˜ï¼šadvantage, endgame, rookEndgame, shortï¼›é¢„æœŸ 2 æ‰‹ã€‚",
        difficulty: "ç®€å•"
      },
      {
        id: "0009B",
        fen: "r2qr1k1/b1p2ppp/pp4n1/P1P1p3/4P1n1/B2P2Pb/3NBP1P/RN1QR1K1 b - - 1 16",
        solution: [
          { move: "b6c5", reply: "e2g4" },
          { move: "h3g4", reply: "d1g4" }
        ],
        title: "Lichess å¼€æºè°œé¢˜ 0009B",
        description: "ä¸»é¢˜ï¼šadvantage, middlegame, shortï¼›é¢„æœŸ 2 æ‰‹ã€‚",
        difficulty: "ç®€å•"
      },
      {
        id: "000Pw",
        fen: "6k1/5p1p/4p3/4q3/3nN3/2Q3P1/PP3P1P/6K1 w - - 2 37",
        solution: [
          { move: "e4d2", reply: "d4e2" },
          { move: "g1f1", reply: "e2c3" }
        ],
        title: "Lichess å¼€æºè°œé¢˜ 000Pw",
        description: "ä¸»é¢˜ï¼šcrushing, endgame, fork, shortï¼›é¢„æœŸ 2 æ‰‹ã€‚",
        difficulty: "ä¸­ç­‰"
      },
      {
        id: "000VW",
        fen: "r4r2/1p3pkp/p5p1/3R1N1Q/3P4/8/P1q2P2/3R2K1 b - - 3 25",
        solution: [
          { move: "g6f5", reply: "d5c5" },
          { move: "c2e4", reply: "h5g5" },
          { move: "g7h8", reply: "g5f6" }
        ],
        title: "Lichess å¼€æºè°œé¢˜ 000VW",
        description: "ä¸»é¢˜ï¼šcrushing, endgame, longï¼›é¢„æœŸ 3 æ‰‹ã€‚",
        difficulty: "å›°éš¾"
      },
      {
        id: "000Vc",
        fen: "8/8/4k1p1/2KpP2p/5PP1/8/8/8 w - - 0 53",
        solution: [
          { move: "g4h5", reply: "g6h5" },
          { move: "f4f5", reply: "e6e5" },
          { move: "f5f6", reply: "e5f6" }
        ],
        title: "Lichess å¼€æºè°œé¢˜ 000Vc",
        description: "ä¸»é¢˜ï¼šcrushing, endgame, long, pawnEndgameï¼›é¢„æœŸ 3 æ‰‹ã€‚",
        difficulty: "ä¸­ç­‰"
      },
      {
        id: "000Zo",
        fen: "4r3/1k6/pp3r2/1b2P2p/3R1p2/P1R2P2/1P4PP/6K1 w - - 0 35",
        solution: [
          { move: "e5f6", reply: "e8e1" },
          { move: "g1f2", reply: "e1f1" }
        ],
        title: "Lichess å¼€æºè°œé¢˜ 000Zo",
        description: "ä¸»é¢˜ï¼šendgame, mate, mateIn2, shortï¼›é¢„æœŸ 2 æ‰‹ã€‚",
        difficulty: "ç®€å•"
      }
    ];

    // --- Components ---

    const Header = ({ goHome }) => (
      <div className="w-full flex items-center justify-between p-6 max-w-6xl mx-auto select-none">
        <div className="flex items-center gap-3 cursor-pointer group" onClick={goHome}>
          <div className="w-10 h-10 bg-black text-white rounded-full flex items-center justify-center text-xl font-bold font-quirky group-hover:scale-110 transition-transform">
            C
          </div>
          <h1 className="text-2xl font-bold font-quirky text-gray-800 tracking-tight">
            Chess Fun <span className="text-gray-400">Labs</span>
          </h1>
        </div>
        <div className="flex gap-4">
          <button className="text-sm font-semibold text-gray-500 hover:text-black transition-colors">v1.2 Integrated</button>
        </div>
      </div>
    );

    const GameCard = ({ title, icon, color, onClick, tag }) => (
      <div
        onClick={onClick}
        className={`game-card relative overflow-hidden bg-white rounded-2xl border-2 border-gray-100 p-6 h-48 flex flex-col justify-between cursor-pointer group hover:border-${color}-400`}
      >
        <div className={`absolute -right-4 -top-4 w-24 h-24 rounded-full bg-${color}-100 opacity-50 group-hover:scale-150 transition-transform duration-500`}></div>
        <div className="z-10 flex justify-between items-start">
          <div className={`p-3 rounded-xl bg-${color}-50 text-${color}-600 text-3xl`}>
            <i className={`ph ${icon}`}></i>
          </div>
          {tag && (
            <span className="px-2 py-1 bg-black text-white text-xs font-bold rounded uppercase tracking-wider">
              {tag}
            </span>
          )}
        </div>
        <div className="z-10">
          <h3 className="font-quirky text-xl font-bold text-gray-800 mb-1">{title}</h3>
          <p className="text-sm text-gray-500 font-medium">å¼€å§‹æŒ‘æˆ˜ &rarr;</p>
        </div>
      </div>
    );

    const Hub = ({ onSelectGame }) => {
      return (
        <div className="min-h-screen pb-20">
          <Header goHome={() => {}} />
          <div className="max-w-6xl mx-auto px-6 mt-10">
            <div className="text-center mb-16">
              <h2 className="text-5xl font-extrabold font-quirky text-gray-900 mb-6 leading-tight">
                è¿™é‡Œçš„å›½é™…è±¡æ£‹ <br />
                <span className="text-transparent bg-clip-text bg-gradient-to-r from-green-500 to-emerald-700">
                  æœ‰ç‚¹ä¸ä¸€æ ·
                </span>
              </h2>
              <p className="text-xl text-gray-500 max-w-2xl mx-auto">
                Stockfish å¼•æ“ç°å·²é›†æˆã€‚ç•…äº«ä¸æ»‘çš„äººæœºå¯¹æˆ˜ä¸æ®‹å±€æŒ‘æˆ˜ã€‚
              </p>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              <GameCard title="æ®‹å±€æŒ‘æˆ˜ (Puzzles)" icon="ph-strategy" color="green" tag="ç»å…¸" onClick={() => onSelectGame('puzzles')} />
              <GameCard title="å¯¹æˆ˜ç”µè„‘ (Play vs AI)" icon="ph-robot" color="teal" tag="å·²ä¿®å¤" onClick={() => onSelectGame('computer')} />
              <GameCard title="ä¸å…¬å¹³å¯¹æˆ˜ (Unfair)" icon="ph-sword" color="red" tag="Hard" onClick={() => onSelectGame('unfair')} />
            </div>
          </div>
        </div>
      );
    };

    const ChessSquare = ({ square, squareName, color, isHighlight, isSelected, isLastMove, isHint, onSquareClick, onDrop }) => {
      const pieceSources = square ? getPieceImg(square.color === 'w' ? 'w' : 'b', square.type) : null;
      
      // Simple Drag & Drop
      const handleDragStart = (e) => {
        if (!square) return;
        e.dataTransfer.setData("text/plain", squareName);
        e.dataTransfer.effectAllowed = "move";
      };
      const handleDragOver = (e) => { e.preventDefault(); };
      const handleDrop = (e) => {
        e.preventDefault();
        const fromSquare = e.dataTransfer.getData("text/plain");
        if (fromSquare && fromSquare !== squareName) {
          onDrop(fromSquare, squareName);
        }
      };

      return (
        <div
          className={`square ${color} ${isHighlight ? 'highlight' : ''} ${isSelected ? 'selected' : ''} ${isLastMove ? 'last-move' : ''} ${isHint ? 'ring-4 ring-yellow-400 ring-offset-2 ring-offset-transparent' : ''} w-full h-full flex items-center justify-center relative select-none`}
          onClick={onSquareClick}
          onDragOver={handleDragOver}
          onDrop={handleDrop}
        >
          {pieceSources && (
            <div
              className="chess-piece w-4/5 h-4/5 z-10 flex items-center justify-center"
              draggable={true}
              onDragStart={handleDragStart}
            >
              <img
                src={pieceSources.assetPath}
                alt={`${square.color}${square.type}`}
                className="w-full h-full object-contain drop-shadow-sm pointer-events-none"
                style={{ filter: square.color === 'w' ? 'drop-shadow(0 2px 3px rgba(0,0,0,0.2))' : 'drop-shadow(0 2px 3px rgba(0,0,0,0.4))' }}
              />
            </div>
          )}
          {isHighlight && !pieceSources && (
            <div className="w-3 h-3 bg-black opacity-20 rounded-full pointer-events-none"></div>
          )}
        </div>
      );
    };

    // --- Puzzle Game Component ---
    const PuzzleGame = ({ goBack, chessLib, onImportToComputer }) => {
      const [game, setGame] = useState(null);
      const [idx, setIdx] = useState(0);
      const [selectedSquare, setSelectedSquare] = useState(null);
      const [possibleMoves, setPossibleMoves] = useState([]);
      const [status, setStatus] = useState("playing"); // playing, correct, wrong
      const [lastMoveSquares, setLastMoveSquares] = useState([]);
      const [step, setStep] = useState(0);
      const [puzzleError, setPuzzleError] = useState(null);
      const [hintSquares, setHintSquares] = useState([]);
      const [hintText, setHintText] = useState(null);

      const currentPuzzle = PUZZLES[idx];

      useEffect(() => {
        if (chessLib) {
          const g = new chessLib(currentPuzzle.fen);
          setGame(g);
          setStatus("playing");
          setLastMoveSquares([]);
          setStep(0);
          setPossibleMoves([]);
          setSelectedSquare(null);
          setHintSquares([]);
          setHintText(null);
        }
      }, [idx, chessLib]);

      // Validate puzzle scriptability to avoidæ— è§£çš„å…³å¡
      useEffect(() => {
        if (!chessLib) return;
        try {
          const g = new chessLib(currentPuzzle.fen);
          currentPuzzle.solution.forEach((stepObj, i) => {
            const move = stepObj.move;
            const mv = g.move({ from: move.slice(0,2), to: move.slice(2,4), promotion: 'q' });
            if (!mv) throw new Error(`ç¬¬ ${i+1} æ‰‹ç©å®¶èµ°å­éæ³•: ${move}`);
            if (stepObj.reply) {
              const reply = stepObj.reply;
              const rv = g.move({ from: reply.slice(0,2), to: reply.slice(2,4), promotion: 'q' });
              if (!rv) throw new Error(`ç¬¬ ${i+1} æ‰‹åº”æ‹›éæ³•: ${reply}`);
            }
          });
          setPuzzleError(null);
        } catch (err) {
          console.error(err);
          setPuzzleError(err.message || "å…³å¡è„šæœ¬éæ³•");
        }
      }, [currentPuzzle, chessLib]);

      const onDrop = (from, to) => {
        if (!game || status !== 'playing') return;
        
        // Validation
        const steps = currentPuzzle.solution;
        const currentStepObj = steps[step];
        const neededMove = currentStepObj.move; // e.g., "g4g6"

        const gCopy = new chessLib(game.fen());
        try {
          const moveResult = gCopy.move({ from, to, promotion: 'q' });
          if (!moveResult) return;

          const moveStr = from + to;
          if (moveStr !== neededMove) {
            setStatus("wrong");
            setHintSquares([]);
            setHintText(null);
            setTimeout(() => {
                // Reset board on wrong move
                const resetG = new chessLib(currentPuzzle.fen);
                setGame(resetG);
                setStatus("playing");
                setStep(0);
                setLastMoveSquares([]);
                setHintSquares([]);
                setHintText(null);
            }, 800);
            return;
          }

          // Correct Move
          playMoveSound();
          setGame(gCopy);
          setLastMoveSquares([from, to]);
          setHintSquares([]);
          setHintText(null);
          
          // Check if puzzle ended or computer reply
          if (step + 1 >= steps.length && !currentStepObj.reply) {
             setStatus("correct");
          } else {
             // Handle reply or next step
             if (currentStepObj.reply) {
                setTimeout(() => {
                   const replyFrom = currentStepObj.reply.slice(0,2);
                   const replyTo = currentStepObj.reply.slice(2,4);
                   gCopy.move({ from: replyFrom, to: replyTo });
                   setGame(new chessLib(gCopy.fen()));
                   setLastMoveSquares([replyFrom, replyTo]);
                   playMoveSound();
                   
                   if (step + 1 >= steps.length) {
                       setStatus("correct");
                   } else {
                       setStep(s => s + 1);
                   }
                }, 400);
             } else {
                setStep(s => s + 1);
             }
          }
        } catch(e) { console.error(e); }
      };

      const onSquareClick = (sq) => {
          if (!game || status !== 'playing') return;
          if (selectedSquare === sq) { setSelectedSquare(null); setPossibleMoves([]); return; }
          if (possibleMoves.includes(sq)) { onDrop(selectedSquare, sq); setSelectedSquare(null); setPossibleMoves([]); return; }
          
          const p = game.get(sq);
          if (p && p.color === game.turn()) {
              setSelectedSquare(sq);
              const moves = game.moves({ square: sq, verbose: true });
              setPossibleMoves(moves.map(m => m.to));
          } else {
              setSelectedSquare(null); setPossibleMoves([]);
          }
      };

      const showHint = () => {
          if (status !== 'playing') return;
          const steps = currentPuzzle.solution;
          const currentStepObj = steps[step];
          if (!currentStepObj) return;
          const from = currentStepObj.move.slice(0,2);
          const to = currentStepObj.move.slice(2,4);
          setHintSquares([from, to]);
          setHintText(`æç¤ºï¼š${from} â†’ ${to}`);
      };

      if (!game) return <div>Loading...</div>;

      const board = [];
      const files = ['a','b','c','d','e','f','g','h'];
      const ranks = ['8','7','6','5','4','3','2','1'];
      const squareCenter = (sq) => {
         const fileIdx = files.indexOf(sq[0]);
         const rankIdx = ranks.indexOf(sq[1]);
         return { x: (fileIdx + 0.5) * 12.5, y: (rankIdx + 0.5) * 12.5 };
      };

      const renderHintArrow = () => {
        if (!hintSquares || hintSquares.length < 2) return null;
        const from = hintSquares[0];
        const to = hintSquares[1];
        const a = squareCenter(from);
        const b = squareCenter(to);
        const dx = Math.abs(a.x - b.x);
        const dy = Math.abs(a.y - b.y);
        let pathD;
        if ((dx === 12.5 && dy === 25) || (dx === 25 && dy === 12.5)) {
           // Knight move: use two segments (L shape)
           const mid = { x: a.x, y: b.y };
           pathD = `M ${a.x} ${a.y} L ${mid.x} ${mid.y} L ${b.x} ${b.y}`;
        } else {
           // Straight/diagonal curve
           const cx = (a.x + b.x) / 2;
           const cy = (a.y + b.y) / 2;
           pathD = `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`;
        }
        return (
          <svg className="absolute inset-0 pointer-events-none" viewBox="0 0 100 100">
            <defs>
              <marker id="hint-arrow-head" markerWidth="4" markerHeight="4" refX="2" refY="2" orient="auto">
                <path d="M0,0 L4,2 L0,4 z" fill="#f59e0b" />
              </marker>
            </defs>
            <path d={pathD} fill="none" stroke="#f59e0b" strokeWidth="1.5" markerEnd="url(#hint-arrow-head)" strokeLinecap="round" strokeLinejoin="round" />
          </svg>
        );
      };
      for(let r=0; r<8; r++) {
          for(let f=0; f<8; f++) {
              const sq = files[f]+ranks[r];
              board.push(
                  <ChessSquare 
                    key={sq} 
                    squareName={sq} 
                    square={game.get(sq)} 
                    color={(r+f)%2===1 ? 'black' : 'white'}
                    isHighlight={possibleMoves.includes(sq)}
                    isSelected={selectedSquare === sq}
                    isLastMove={lastMoveSquares.includes(sq)}
                    isHint={false}
                    onSquareClick={() => onSquareClick(sq)}
                    onDrop={onDrop}
                  />
              );
          }
      }

      return (
        <div className="min-h-screen bg-gray-50 flex flex-col">
          <Header goHome={goBack} />
          <div className="flex-1 flex flex-col lg:flex-row items-center justify-center gap-8 px-4 pb-12">
              <div className="relative">
                <div className="w-full max-w-[500px] aspect-square rounded-lg shadow-xl overflow-hidden border-4 border-gray-800 bg-gray-800 grid grid-cols-8 grid-rows-8 relative">
                   {board}
                   {renderHintArrow()}
                 
                   {/* Game over overlay remains */}
                </div>
              {/* Files */}
              <div className="absolute -bottom-6 inset-x-0 grid grid-cols-8 text-center text-xs sm:text-sm text-gray-700 font-semibold pointer-events-none">
                {files.map(f => <span key={`file-${f}`}>{f}</span>)}
              </div>
              {/* Ranks */}
              <div className="absolute inset-y-0 -left-6 grid grid-rows-8 text-xs sm:text-sm text-gray-700 font-semibold pointer-events-none">
                {ranks.map(r => (
                  <div key={`rank-${r}`} className="flex items-center justify-center">
                    {r}
                  </div>
                ))}
              </div>
            </div>
            <div className="w-full max-w-md bg-white rounded-2xl shadow-xl p-6 flex flex-col gap-6">
               <div>
                   <div className="flex flex-col gap-2 mb-2">
                     <div className="flex justify-between items-center gap-3 flex-wrap">
                       <span className="bg-green-100 text-green-700 font-bold px-3 py-1 rounded-full text-sm">Puzzle #{idx+1} Â· ID {currentPuzzle.id}</span>
                       <span className="text-xs bg-gray-100 text-gray-700 px-2 py-1 rounded">éš¾åº¦ï¼š{currentPuzzle.difficulty}</span>
                     </div>
                     <div className="flex gap-2">
                       <select
                         className="flex-1 border rounded-lg px-3 py-2 text-sm"
                         value={currentPuzzle.id}
                         onChange={(e) => {
                           const targetIdx = PUZZLES.findIndex(p => String(p.id) === e.target.value);
                           if (targetIdx >= 0) setIdx(targetIdx);
                         }}
                       >
                         {PUZZLES.map((p, i) => (
                           <option key={p.id} value={p.id}>
                             #{i+1} Â· {p.title} Â· {p.difficulty}
                           </option>
                         ))}
                       </select>
                       <button
                         onClick={() => {
                           const next = (idx + 1) % PUZZLES.length;
                           setIdx(next);
                         }}
                         className="px-3 py-2 text-sm rounded-lg bg-gray-100 hover:bg-gray-200"
                       >
                         éšæœº/ä¸‹ä¸€
                       </button>
                     </div>
                   </div>
                   <h2 className="text-2xl font-bold mb-2">{currentPuzzle.title}</h2>
                   <p className="text-gray-600">{currentPuzzle.description}</p>
                   {puzzleError && (
                     <div className="mt-3 text-sm text-red-600 bg-red-50 border border-red-200 rounded-lg px-3 py-2">
                       å…³å¡æ ¡éªŒå¤±è´¥ï¼š{puzzleError}
                     </div>
                   )}
                </div>
                <div className="flex-1 min-h-[100px] flex items-center justify-center bg-gray-50 rounded-xl border-2 border-dashed border-gray-200">
                    {status === 'playing' && <div className="text-gray-400">è¯·èµ°å‡ºæœ€ä½³çš„ä¸€æ­¥...</div>}
                    {status === 'correct' && <div className="text-green-600 font-bold text-xl">ğŸ‰ æ­£ç¡®!</div>}
                    {status === 'wrong' && <div className="text-red-500 font-bold">âŒ èµ°é”™äº†ï¼Œé‡è¯•ä¸­...</div>}
                </div>
                <div className="flex flex-col gap-3">
                  <div className="flex items-center gap-3">
                    <button
                      onClick={showHint}
                      disabled={status !== 'playing'}
                      className={`flex-1 py-2 rounded-lg font-semibold ${status === 'playing' ? 'bg-yellow-100 text-yellow-800 hover:bg-yellow-200' : 'bg-gray-200 text-gray-400 cursor-not-allowed'}`}
                    >
                      æç¤ºï¼ˆæ˜¾ç¤ºæœ€ä½³èµ°æ³•ï¼‰
                    </button>
                    {hintText && <span className="text-sm text-yellow-800">{hintText}</span>}
                  </div>
                  <button 
                    onClick={() => idx < PUZZLES.length-1 ? setIdx(i=>i+1) : alert("All Done!")} 
                    disabled={status !== 'correct'}
                    className={`w-full py-3 rounded-xl font-bold ${status==='correct' ? 'bg-green-500 text-white shadow-lg shadow-green-200 hover:bg-green-600' : 'bg-gray-200 text-gray-400 cursor-not-allowed'}`}
                  >
                    ä¸‹ä¸€å…³
                  </button>
                  <button 
                    onClick={() => onImportToComputer && onImportToComputer(currentPuzzle.fen)}
                    className="w-full py-3 rounded-xl font-bold bg-blue-50 text-blue-700 hover:bg-blue-100 border border-blue-200"
                  >
                    å¯¼å…¥å½“å‰å±€é¢åˆ°äººæœºåˆ†æ
                  </button>
                </div>
            </div>
          </div>
        </div>
      );
    };

    // --- Computer Game Component ---
    const ComputerGame = ({ goBack, chessLib, initialFen, onFenConsumed }) => {
      const [game, setGame] = useState(null);
      const [level, setLevel] = useState("800");
      const [engineReady, setEngineReady] = useState(false);
      const [isThinking, setIsThinking] = useState(false);
      const [evalScore, setEvalScore] = useState(null);
      const [history, setHistory] = useState([]); // For undo
      const [lastMoveSquares, setLastMoveSquares] = useState([]);
      const [selectedSquare, setSelectedSquare] = useState(null);
      const [possibleMoves, setPossibleMoves] = useState([]);
      const [engineError, setEngineError] = useState(null);
      const evalPerspectiveRef = useRef('w');
      const [hintMove, setHintMove] = useState(null);
      const [hintLoading, setHintLoading] = useState(false);
      const importedFenPlayedRef = useRef(false);
      
      const engineRef = useRef(null);

      // Init Engine
      useEffect(() => {
        if (!chessLib) return;
        const g = new chessLib(initialFen || undefined);
        setGame(g);
        setHistory([g.fen()]);

        const client = createEngineClient(
            (err) => setEngineError(err),
            (log) => {}, // console.log(log), // Optional debug
            (evalData) => {
                // Normalize evaluation to White's perspective for display consistency
                // Note: Stockfish usually sends eval relative to side to move.
                setEvalScore({ ...evalData, turn: evalPerspectiveRef.current });
            }
        );
        engineRef.current = client;

        client.init()
          .then(() => setEngineReady(true))
          .catch(err => setEngineError("æ— æ³•è¿æ¥ Stockfish CDN"));

        return () => {
          client.terminate();
        };
      }, [chessLib]);

      // If imported FEN provided, switchåˆ°æœ€å¼ºæ¡£
      useEffect(() => {
        if (initialFen) {
          setLevel("2500");
          importedFenPlayedRef.current = false;
        }
      }, [initialFen]);

      // Apply imported FEN after init
      useEffect(() => {
        if (!chessLib || !initialFen) return;
        try {
          const g = new chessLib(initialFen);
          setGame(g);
          setHistory([g.fen()]);
          setLastMoveSquares([]);
          setEvalScore(null);
          setIsThinking(false);
          setHintMove(null);
          setSelectedSquare(null);
          setPossibleMoves([]);
          engineRef.current?.stop();
          onFenConsumed && onFenConsumed();
          importedFenPlayedRef.current = false;
        } catch (e) {
          console.error("Failed to load imported FEN", e);
        }
      }, [initialFen, chessLib, onFenConsumed]);

      // If imported FEN starts withé»‘æ–¹èµ°ï¼Œè‡ªåŠ¨è®©å¼•æ“å…ˆèµ°
      useEffect(() => {
        if (!engineReady || !game || !initialFen) return;
        if (importedFenPlayedRef.current) return;
        if (game.turn() === 'b') {
          importedFenPlayedRef.current = true;
          makeAiMove(game.fen());
        }
      }, [engineReady, game, initialFen, makeAiMove]);

      // AI Logic
      const makeAiMove = useCallback(async (currentFen) => {
         if (!engineRef.current || !engineReady) return;
         
         setIsThinking(true);
         try {
             // è®°å½•å½“å‰è¯„ä¼°è§†è§’ï¼ˆå½“å‰å±€é¢çš„è¡Œæ£‹æ–¹ï¼‰
             const fenTurn = new chessLib(currentFen).turn();
             evalPerspectiveRef.current = fenTurn;
         } catch(e) {}
         try {
             const bestMove = await engineRef.current.go({
                 fen: currentFen,
                 level: ENGINE_LEVELS[level]
             });
             
             if (bestMove && bestMove !== '(none)') {
                 const from = bestMove.substring(0,2);
                 const to = bestMove.substring(2,4);
                 const promotion = bestMove.length > 4 ? bestMove.substring(4) : 'q';
                 
                 setGame(prevGame => {
                     const newG = new chessLib(prevGame.fen());
                     const move = newG.move({ from, to, promotion });
                     if (move) {
                         playMoveSound();
                         setHistory(h => [...h, newG.fen()]);
                         setLastMoveSquares([from, to]);
                         setHintMove(null);
                         return newG;
                     }
                     return prevGame;
                 });
             }
         } catch(e) {
             console.error("AI Move Error", e);
         } finally {
             setIsThinking(false);
         }
      }, [engineReady, level, chessLib]);

      // Handle Player Move
      const onDrop = (from, to) => {
          // FIX: Replaced game.isGameOver() with game.game_over() for chess.js 0.10.x compatibility
          if (!game || isThinking || game.turn() !== 'w' || game.game_over()) return;
          
          const newG = new chessLib(game.fen());
          try {
              const move = newG.move({ from, to, promotion: 'q' });
              if (!move) return; // illegal
              
              playMoveSound();
              setGame(newG);
              setHistory(h => [...h, newG.fen()]);
              setLastMoveSquares([from, to]);
              setSelectedSquare(null);
              setPossibleMoves([]);
              setHintMove(null);
              
              // Trigger AI
              // FIX: Replaced newG.isGameOver() with newG.game_over()
              if (!newG.game_over()) {
                  // Small delay for realism
                  setTimeout(() => makeAiMove(newG.fen()), 200);
              }
          } catch(e) {}
      };

      const onSquareClick = (sq) => {
          if (!game || isThinking || game.turn() !== 'w') return;
          
          if (selectedSquare === sq) { setSelectedSquare(null); setPossibleMoves([]); return; }
          if (possibleMoves.includes(sq)) { onDrop(selectedSquare, sq); return; }
          
          const p = game.get(sq);
          if (p && p.color === 'w') {
              setSelectedSquare(sq);
              const moves = game.moves({ square: sq, verbose: true });
              setPossibleMoves(moves.map(m => m.to));
          } else {
              setSelectedSquare(null); setPossibleMoves([]);
          }
      };

      const handleUndo = () => {
          if (isThinking || history.length < 2) return; // need at least a previous state
          const stepsToRevert = history.length >= 3 ? 2 : 1; // ifåŒæ–¹å·²èµ°ï¼Œæ’¤å›ä¸€æ•´å›åˆï¼Œå¦åˆ™æ’¤å›ä¸Šä¸€æ‰‹
          const newHistory = history.slice(0, history.length - stepsToRevert);
          if (newHistory.length === 0) return;
          const oldFen = newHistory[newHistory.length - 1];
          setGame(new chessLib(oldFen));
          setHistory(newHistory);
          setLastMoveSquares([]);
          setHintMove(null);
          engineRef.current.stop();
          setIsThinking(false);
      };

      const resetGame = () => {
          const g = new chessLib();
          setGame(g);
          setHistory([g.fen()]);
          setLastMoveSquares([]);
          setEvalScore(null);
          setIsThinking(false);
          setHintMove(null);
          engineRef.current.stop();
      };

      if (!game) return <div className="h-screen flex items-center justify-center">Loading Engine...</div>;

      // Board Render
      const board = [];
      const files = ['a','b','c','d','e','f','g','h'];
      const ranks = ['8','7','6','5','4','3','2','1'];
      for(let r=0; r<8; r++) {
          for(let f=0; f<8; f++) {
              const sq = files[f]+ranks[r];
              board.push(
                  <ChessSquare 
                    key={sq} 
                    squareName={sq} 
                    square={game.get(sq)} 
                    color={(r+f)%2===1 ? 'black' : 'white'}
                    isHighlight={possibleMoves.includes(sq)}
                    isSelected={selectedSquare === sq}
                    isLastMove={lastMoveSquares.includes(sq)}
                    isHint={false}
                    onSquareClick={() => onSquareClick(sq)}
                    onDrop={onDrop}
                  />
              );
          }
      }

      const squareCenter = (sq) => {
         const fileIdx = files.indexOf(sq[0]);
         const rankIdx = ranks.indexOf(sq[1]);
         return { x: (fileIdx + 0.5) * 12.5, y: (rankIdx + 0.5) * 12.5 };
      };

      const renderHintArrow = () => {
        if (!hintMove) return null;
        const from = hintMove.from;
        const to = hintMove.to;
        const a = squareCenter(from);
        const b = squareCenter(to);
        const dx = Math.abs(a.x - b.x);
        const dy = Math.abs(a.y - b.y);
        let pathD;
        if ((dx === 12.5 && dy === 25) || (dx === 25 && dy === 12.5)) {
           const mid = { x: a.x, y: b.y };
           pathD = `M ${a.x} ${a.y} L ${mid.x} ${mid.y} L ${b.x} ${b.y}`;
        } else {
           const cx = (a.x + b.x) / 2;
           const cy = (a.y + b.y) / 2;
           pathD = `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`;
        }
        return (
          <svg className="absolute inset-0 pointer-events-none" viewBox="0 0 100 100">
            <defs>
              <marker id="hint-arrow-head-ai" markerWidth="4" markerHeight="4" refX="2" refY="2" orient="auto">
                <path d="M0,0 L4,2 L0,4 z" fill="#f59e0b" />
              </marker>
            </defs>
            <path d={pathD} fill="none" stroke="#f59e0b" strokeWidth="1.5" markerEnd="url(#hint-arrow-head-ai)" strokeLinecap="round" strokeLinejoin="round" />
          </svg>
        );
      };

      const getEvalSummary = () => {
        if (!game || !evalScore) return { whitePercent: 0.5, label: 'å‡åŠ¿' };
        const perspective = evalScore.turn || 'w';
        let score = evalScore.type === 'mate'
          ? (evalScore.value > 0 ? 1000 : -1000)
          : evalScore.value;
        // Stockfish æŠ¥å‘Šé€šå¸¸ä»¥èµ°æ£‹æ–¹è§†è§’ï¼Œæ¢ç®—æˆç™½æ–¹è§†è§’
        if (perspective === 'b') score = -score;
        if (evalScore.type === 'mate') {
          return {
            whitePercent: score > 0 ? 1 : 0,
            label: score > 0 ? 'ç™½æ–¹å¿…èƒœ' : 'é»‘æ–¹å¿…èƒœ'
          };
        }
        const clamped = Math.max(-600, Math.min(600, score)); // é™åˆ¶åœ¨ Â±6 åˆ†
        const whitePercent = (clamped + 600) / 1200;
        const label = `${score >= 0 ? '+' : ''}${(score/100).toFixed(2)}`;
        return { whitePercent, label };
      };

      const evalSummary = getEvalSummary();

      return (
        <div className="min-h-screen bg-gray-50 flex flex-col">
          <Header goHome={goBack} />
          <div className="flex-1 flex flex-col lg:flex-row items-center justify-center gap-8 px-4 pb-12">
            <div className="flex items-center gap-4 w-full max-w-[600px]">
              <div className="hidden sm:flex flex-col items-center">
                <div className="relative h-[420px] w-7 rounded-full overflow-hidden border-2 border-gray-300 bg-gray-200 shadow-inner">
                  <div
                    className="absolute left-0 right-0 bg-black"
                    style={{ height: `${(1 - evalSummary.whitePercent) * 100}%`, top: 0 }}
                  ></div>
                  <div
                    className="absolute left-0 right-0 bg-white"
                    style={{ height: `${evalSummary.whitePercent * 100}%`, bottom: 0 }}
                  ></div>
                  <div
                    className="absolute left-0 right-0 flex justify-center"
                    style={{ bottom: `${evalSummary.whitePercent * 100}%` }}
                  >
                    <div className="w-3 h-1 bg-blue-500 rounded"></div>
                  </div>
                </div>
                <div className="text-xs text-gray-500 mt-2 font-mono text-center leading-tight w-20">{evalSummary.label}</div>
              </div>

              {/* Board */}
              <div className="relative">
                <div className="w-full max-w-[520px] aspect-square rounded-lg shadow-2xl overflow-hidden border-4 border-gray-800 bg-gray-800 grid grid-cols-8 grid-rows-8 relative">
                    {board}
                    {hintMove && renderHintArrow()}
                    
                    {/* FIX: Replaced isGameOver() with game_over() and isCheckmate() with in_checkmate() */}
                    {game.game_over() && (
                        <div className="absolute inset-0 bg-black/60 flex items-center justify-center z-20 backdrop-blur-sm">
                            <div className="bg-white p-6 rounded-xl text-center shadow-2xl">
                                <h2 className="text-2xl font-bold mb-2">æ¸¸æˆç»“æŸ</h2>
                                <p className="text-gray-600 mb-4">
                                    {game.in_checkmate() ? (game.turn() === 'w' ? "ä½ è¾“äº†" : "ä½ èµ¢äº†ï¼") : "å’Œæ£‹"}
                                </p>
                                <button onClick={resetGame} className="px-4 py-2 bg-blue-600 text-white rounded-lg font-bold">å†æ¥ä¸€å±€</button>
                            </div>
                        </div>
                    )}
                </div>
                {/* Files */}
                <div className="absolute -bottom-6 inset-x-0 grid grid-cols-8 text-center text-xs sm:text-sm text-gray-700 font-semibold pointer-events-none">
                  {files.map(f => <span key={`file-ai-${f}`}>{f}</span>)}
                </div>
                {/* Ranks */}
                <div className="absolute inset-y-0 -left-6 grid grid-rows-8 text-xs sm:text-sm text-gray-700 font-semibold pointer-events-none">
                  {ranks.map(r => (
                    <div key={`rank-ai-${r}`} className="flex items-center justify-center">
                      {r}
                    </div>
                  ))}
                </div>
              </div>
            </div>

            {/* Controls */}
            <div className="w-full max-w-md bg-white rounded-2xl shadow-xl p-6 flex flex-col gap-6">
                <div className="flex justify-between items-center">
                    <span className="flex items-center gap-2 font-bold text-gray-700">
                        <i className="ph ph-robot text-xl"></i> Stockfish 10
                    </span>
                    <span className={`text-xs font-bold px-2 py-1 rounded uppercase tracking-wider ${engineReady ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'}`}>
                        {engineReady ? "Online" : "Loading..."}
                    </span>
                </div>

                {engineError && (
                    <div className="p-3 bg-red-50 text-red-600 text-sm rounded-lg border border-red-100">
                        Error: {engineError}. è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚
                    </div>
                )}

                <div className="flex flex-col gap-2">
                    <label className="text-sm font-semibold text-gray-500">é€‰æ‹©éš¾åº¦ (Rating)</label>
                    <div className="flex flex-wrap gap-2">
                        {Object.keys(ENGINE_LEVELS).map(lvl => (
                            <button 
                                key={lvl}
                                onClick={() => { setLevel(lvl); resetGame(); }}
                                className={`px-3 py-1 text-sm rounded-full border transition-colors ${level === lvl ? 'bg-blue-600 text-white border-blue-600' : 'bg-gray-50 text-gray-600 border-gray-200 hover:border-blue-300'}`}
                            >
                                {lvl}
                            </button>
                        ))}
                    </div>
                </div>

                <div className="flex-1 min-h-[120px] flex items-center justify-center bg-gray-50 rounded-xl border-2 border-dashed border-gray-200 relative overflow-hidden">
                    {isThinking ? (
                        <div className="flex flex-col items-center gap-2 text-blue-600">
                             <i className="ph ph-spinner animate-spin text-3xl"></i>
                             <span className="font-bold text-sm">æ€è€ƒä¸­...</span>
                        </div>
                    ) : (
                        <div className="flex flex-col items-center gap-1 text-gray-400">
                            {game.turn() === 'w' ? <span>è½®åˆ°ä½ èµ°æ£‹ (æ‰§ç™½)</span> : <span>ç­‰å¾…ç”µè„‘...</span>}
                            {evalScore && (
                                <span className="text-xs font-mono mt-2 bg-gray-200 px-2 py-1 rounded">
                                    Eval: {evalSummary.label}
                                </span>
                            )}
                            {hintMove && (
                              <span className="text-xs font-mono mt-1 bg-yellow-100 text-yellow-800 px-2 py-1 rounded">
                                æç¤ºï¼š{hintMove.from}â†’{hintMove.to}
                              </span>
                            )}
                        </div>
                    )}
                </div>

                <div className="grid grid-cols-2 gap-3">
                    <button onClick={handleUndo} disabled={isThinking || history.length < 2} className="py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-colors disabled:opacity-50">
                        æ‚”æ£‹
                    </button>
                    <button onClick={resetGame} className="py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-lg shadow-blue-200 transition-colors">
                        æ–°æ¸¸æˆ
                    </button>
                    <button
                      onClick={async () => {
                        if (!engineReady || !engineRef.current || !game || isThinking || game.turn() !== 'w') return;
                        setHintLoading(true);
                        setHintMove(null);
                        try {
                          const fen = game.fen();
                          evalPerspectiveRef.current = game.turn();
                          const best = await engineRef.current.go({ fen, level: ENGINE_LEVELS["2500"], movetimeOverride: 2500 });
                          if (best && best !== '(none)') {
                            const from = best.substring(0,2);
                            const to = best.substring(2,4);
                            setHintMove({ from, to, text: `${from}â†’${to}` });
                          }
                        } catch (e) {
                          console.error("hint error", e);
                        } finally {
                          setHintLoading(false);
                        }
                      }}
                      disabled={!engineReady || !game || isThinking || game.turn() !== 'w' || hintLoading}
                      className="py-3 col-span-2 bg-yellow-100 hover:bg-yellow-200 text-yellow-800 rounded-xl font-bold transition-colors disabled:opacity-50"
                    >
                      {hintLoading ? 'è®¡ç®—æç¤º...' : 'æç¤ºæœ€ä½³èµ°æ³•'}
                    </button>
                </div>
            </div>
          </div>
        </div>
      );
    };

    // --- Unfair Game Component ---
    const UnfairGame = ({ goBack, chessLib, losses, onRecordLoss }) => {
      const [game, setGame] = useState(null);
      const [engineReady, setEngineReady] = useState(false);
      const [isThinking, setIsThinking] = useState(false);
      const [evalScore, setEvalScore] = useState(null);
      const [history, setHistory] = useState([]);
      const [lastMoveSquares, setLastMoveSquares] = useState([]);
      const [selectedSquare, setSelectedSquare] = useState(null);
      const [possibleMoves, setPossibleMoves] = useState([]);
      const [engineError, setEngineError] = useState(null);
      const evalPerspectiveRef = useRef('w');
      const [hintMove, setHintMove] = useState(null);
      const [hintLoading, setHintLoading] = useState(false);

      const engineRef = useRef(null);

      const computeHandicapFen = useCallback((lossCount) => {
        const g = new chessLib();
        const targets = ['b1','g1','c1','f1','a1','h1']; // knights, bishops, rooks
        let remaining = lossCount;
        for (const sq of targets) {
          if (remaining <= 0) break;
          const p = g.get(sq);
          if (p && p.color === 'w' && ['r','n','b'].includes(p.type)) {
            g.remove(sq);
            g.put({ type: 'q', color: 'w' }, sq);
            remaining -= 1;
          }
        }
        return g.fen();
      }, [chessLib]);

      // Init
      useEffect(() => {
        if (!chessLib) return;
        const startFen = computeHandicapFen(losses);
        const g = new chessLib(startFen);
        setGame(g);
        setHistory([g.fen()]);

        const client = createEngineClient(
            (err) => setEngineError(err),
            (log) => {},
            (evalData) => {
                setEvalScore({ ...evalData, turn: evalPerspectiveRef.current });
            }
        );
        engineRef.current = client;

        client.init()
          .then(() => setEngineReady(true))
          .catch(err => setEngineError("æ— æ³•è¿æ¥ Stockfish CDN"));

        return () => {
          client.terminate();
        };
      }, [chessLib, computeHandicapFen, losses]);

      // Rebuild board on new losses
      useEffect(() => {
        if (!chessLib || !engineReady) return;
        const startFen = computeHandicapFen(losses);
        const g = new chessLib(startFen);
        setGame(g);
        setHistory([g.fen()]);
        setLastMoveSquares([]);
        setEvalScore(null);
        setIsThinking(false);
        setHintMove(null);
        setSelectedSquare(null);
        setPossibleMoves([]);
        engineRef.current?.stop();
      }, [losses, chessLib, computeHandicapFen, engineReady]);

      const makeAiMove = useCallback(async (currentFen) => {
         if (!engineRef.current || !engineReady) return;
         
         setIsThinking(true);
         try {
             const fenTurn = new chessLib(currentFen).turn();
             evalPerspectiveRef.current = fenTurn;
         } catch(e) {}
         try {
             const bestMove = await engineRef.current.go({
                 fen: currentFen,
                 level: ENGINE_LEVELS["2500"],
                 movetimeOverride: 2500
             });
             
             if (bestMove && bestMove !== '(none)') {
                 const from = bestMove.substring(0,2);
                 const to = bestMove.substring(2,4);
                 const promotion = bestMove.length > 4 ? bestMove.substring(4) : 'q';
                 
                 setGame(prevGame => {
                     const newG = new chessLib(prevGame.fen());
                     const move = newG.move({ from, to, promotion });
                     if (move) {
                         playMoveSound();
                         setHistory(h => [...h, newG.fen()]);
                         setLastMoveSquares([from, to]);
                         setHintMove(null);
                         return newG;
                     }
                     return prevGame;
                 });
             }
         } catch(e) {
             console.error("AI Move Error", e);
         } finally {
             setIsThinking(false);
         }
      }, [engineReady, chessLib]);

      // If black to move initially, auto-move
      useEffect(() => {
        if (!engineReady || !game) return;
        if (game.turn() === 'b' && !isThinking) {
          makeAiMove(game.fen());
        }
      }, [engineReady, game, isThinking, makeAiMove]);

      const onDrop = (from, to) => {
          if (!game || isThinking || game.turn() !== 'w' || game.game_over()) return;
          
          const newG = new chessLib(game.fen());
          try {
              const move = newG.move({ from, to, promotion: 'q' });
              if (!move) return;
              
              playMoveSound();
              setGame(newG);
              setHistory(h => [...h, newG.fen()]);
              setLastMoveSquares([from, to]);
              setSelectedSquare(null);
              setPossibleMoves([]);
              setHintMove(null);
              
              if (!newG.game_over()) {
                  setTimeout(() => makeAiMove(newG.fen()), 200);
              }
          } catch(e) {}
      };

      const onSquareClick = (sq) => {
          if (!game || isThinking || game.turn() !== 'w') return;
          
          if (selectedSquare === sq) { setSelectedSquare(null); setPossibleMoves([]); return; }
          if (possibleMoves.includes(sq)) { onDrop(selectedSquare, sq); return; }
          
          const p = game.get(sq);
          if (p && p.color === 'w') {
              setSelectedSquare(sq);
              const moves = game.moves({ square: sq, verbose: true });
              setPossibleMoves(moves.map(m => m.to));
          } else {
              setSelectedSquare(null); setPossibleMoves([]);
          }
      };

      const handleUndo = () => {
          if (isThinking || history.length < 2) return;
          const stepsToRevert = history.length >= 3 ? 2 : 1;
          const newHistory = history.slice(0, history.length - stepsToRevert);
          if (newHistory.length === 0) return;
          const oldFen = newHistory[newHistory.length - 1];
          setGame(new chessLib(oldFen));
          setHistory(newHistory);
          setLastMoveSquares([]);
          setHintMove(null);
          engineRef.current.stop();
          setIsThinking(false);
      };

      const resetGame = () => {
          const startFen = computeHandicapFen(losses);
          const g = new chessLib(startFen);
          setGame(g);
          setHistory([g.fen()]);
          setLastMoveSquares([]);
          setEvalScore(null);
          setIsThinking(false);
          setHintMove(null);
          engineRef.current.stop();
      };

      // Detect loss (checkmate vs white or surrender)
      useEffect(() => {
        if (!game) return;
        if (game.game_over() && game.in_checkmate() && game.turn() === 'w') {
          onRecordLoss && onRecordLoss();
        }
      }, [game, onRecordLoss]);

      if (!game) return <div className="h-screen flex items-center justify-center">Loading Engine...</div>;

      // Board Render
      const board = [];
      const files = ['a','b','c','d','e','f','g','h'];
      const ranks = ['8','7','6','5','4','3','2','1'];
      for(let r=0; r<8; r++) {
          for(let f=0; f<8; f++) {
              const sq = files[f]+ranks[r];
              board.push(
                  <ChessSquare 
                    key={sq} 
                    squareName={sq} 
                    square={game.get(sq)} 
                    color={(r+f)%2===1 ? 'black' : 'white'}
                    isHighlight={possibleMoves.includes(sq)}
                    isSelected={selectedSquare === sq}
                    isLastMove={lastMoveSquares.includes(sq)}
                    isHint={false}
                    onSquareClick={() => onSquareClick(sq)}
                    onDrop={onDrop}
                  />
              );
          }
      }

      const squareCenter = (sq) => {
         const fileIdx = files.indexOf(sq[0]);
         const rankIdx = ranks.indexOf(sq[1]);
         return { x: (fileIdx + 0.5) * 12.5, y: (rankIdx + 0.5) * 12.5 };
      };

      const renderHintArrow = () => {
        if (!hintMove) return null;
        const from = hintMove.from;
        const to = hintMove.to;
        const a = squareCenter(from);
        const b = squareCenter(to);
        const dx = Math.abs(a.x - b.x);
        const dy = Math.abs(a.y - b.y);
        let pathD;
        if ((dx === 12.5 && dy === 25) || (dx === 25 && dy === 12.5)) {
           const mid = { x: a.x, y: b.y };
           pathD = `M ${a.x} ${a.y} L ${mid.x} ${mid.y} L ${b.x} ${b.y}`;
        } else {
           const cx = (a.x + b.x) / 2;
           const cy = (a.y + b.y) / 2;
           pathD = `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`;
        }
        return (
          <svg className="absolute inset-0 pointer-events-none" viewBox="0 0 100 100">
            <defs>
              <marker id="hint-arrow-head-unfair" markerWidth="4" markerHeight="4" refX="2" refY="2" orient="auto">
                <path d="M0,0 L4,2 L0,4 z" fill="#f59e0b" />
              </marker>
            </defs>
            <path d={pathD} fill="none" stroke="#f59e0b" strokeWidth="1.5" markerEnd="url(#hint-arrow-head-unfair)" strokeLinecap="round" strokeLinejoin="round" />
          </svg>
        );
      };

      const getEvalSummary = () => {
        if (!game || !evalScore) return { whitePercent: 0.5, label: 'å‡åŠ¿' };
        const perspective = evalScore.turn || 'w';
        let score = evalScore.type === 'mate'
          ? (evalScore.value > 0 ? 1000 : -1000)
          : evalScore.value;
        if (perspective === 'b') score = -score;
        if (evalScore.type === 'mate') {
          return {
            whitePercent: score > 0 ? 1 : 0,
            label: score > 0 ? 'ç™½æ–¹å¿…èƒœ' : 'é»‘æ–¹å¿…èƒœ'
          };
        }
        const clamped = Math.max(-600, Math.min(600, score));
        const whitePercent = (clamped + 600) / 1200;
        const label = `${score >= 0 ? '+' : ''}${(score/100).toFixed(2)}`;
        return { whitePercent, label };
      };

      const evalSummary = getEvalSummary();

      return (
        <div className="min-h-screen bg-gray-50 flex flex-col">
          <Header goHome={goBack} />
          <div className="flex-1 flex flex-col lg:flex-row items-center justify-center gap-8 px-4 pb-12">
            
            <div className="flex items-center gap-4 w-full max-w-[600px]">
              <div className="hidden sm:flex flex-col items-center">
                <div className="relative h-[420px] w-7 rounded-full overflow-hidden border-2 border-gray-300 bg-gray-200 shadow-inner">
                  <div
                    className="absolute left-0 right-0 bg-black"
                    style={{ height: `${(1 - evalSummary.whitePercent) * 100}%`, top: 0 }}
                  ></div>
                  <div
                    className="absolute left-0 right-0 bg-white"
                    style={{ height: `${evalSummary.whitePercent * 100}%`, bottom: 0 }}
                  ></div>
                  <div
                    className="absolute left-0 right-0 flex justify-center"
                    style={{ bottom: `${evalSummary.whitePercent * 100}%` }}
                  >
                    <div className="w-3 h-1 bg-blue-500 rounded"></div>
                  </div>
                </div>
                <div className="text-xs text-gray-500 mt-2 font-mono text-center leading-tight w-20">{evalSummary.label}</div>
              </div>

              <div className="relative">
                <div className="w-full max-w-[520px] aspect-square rounded-lg shadow-2xl overflow-hidden border-4 border-gray-800 bg-gray-800 grid grid-cols-8 grid-rows-8 relative">
                    {board}
                    {hintMove && renderHintArrow()}
                    
                    {game.game_over() && (
                        <div className="absolute inset-0 bg-black/60 flex items-center justify-center z-20 backdrop-blur-sm">
                            <div className="bg-white p-6 rounded-xl text-center shadow-2xl">
                                <h2 className="text-2xl font-bold mb-2">æ¸¸æˆç»“æŸ</h2>
                                <p className="text-gray-600 mb-4">
                                    {game.in_checkmate() ? (game.turn() === 'w' ? "ä½ è¾“äº†" : "ä½ èµ¢äº†ï¼") : "å’Œæ£‹"}
                                </p>
                                <button onClick={resetGame} className="px-4 py-2 bg-blue-600 text-white rounded-lg font-bold">å†æ¥ä¸€å±€</button>
                            </div>
                        </div>
                    )}
                </div>
                <div className="absolute -bottom-6 inset-x-0 grid grid-cols-8 text-center text-xs sm:text-sm text-gray-700 font-semibold pointer-events-none">
                  {files.map(f => <span key={`file-unfair-${f}`}>{f}</span>)}
                </div>
                <div className="absolute inset-y-0 -left-6 grid grid-rows-8 text-xs sm:text-sm text-gray-700 font-semibold pointer-events-none">
                  {ranks.map(r => (
                    <div key={`rank-unfair-${r}`} className="flex items-center justify-center">
                      {r}
                    </div>
                  ))}
                </div>
              </div>
            </div>

            <div className="w-full max-w-md bg-white rounded-2xl shadow-xl p-6 flex flex-col gap-6">
                <div className="flex justify-between items-center">
                    <span className="flex items-center gap-2 font-bold text-gray-700">
                        <i className="ph ph-sword text-xl"></i> ä¸å…¬å¹³å¯¹æˆ˜
                    </span>
                    <span className="text-xs font-bold px-2 py-1 rounded uppercase tracking-wider bg-red-100 text-red-700">
                        æœ€å¼ºå¼•æ“
                    </span>
                </div>

                <div className="flex flex-wrap gap-2 text-sm text-gray-600">
                  <span className="px-2 py-1 bg-gray-100 rounded-lg">å¤±è´¥æ¬¡æ•°ï¼š{losses}</span>
                  <span className="px-2 py-1 bg-blue-50 text-blue-700 rounded-lg">å½“å‰é¢å¤–åï¼š{Math.min(losses,6)}</span>
                </div>

                {engineError && (
                    <div className="p-3 bg-red-50 text-red-600 text-sm rounded-lg border border-red-100">
                        Error: {engineError}. è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚
                    </div>
                )}

                <div className="flex-1 min-h-[120px] flex items-center justify-center bg-gray-50 rounded-xl border-2 border-dashed border-gray-200 relative overflow-hidden">
                    {isThinking ? (
                        <div className="flex flex-col items-center gap-2 text-blue-600">
                             <i className="ph ph-spinner animate-spin text-3xl"></i>
                             <span className="font-bold text-sm">æ€è€ƒä¸­...</span>
                        </div>
                    ) : (
                        <div className="flex flex-col items-center gap-1 text-gray-400">
                            {game.turn() === 'w' ? <span>ä½ çš„å›åˆ (æ‰§ç™½)</span> : <span>ç­‰å¾…ç”µè„‘...</span>}
                            {evalScore && (
                                <span className="text-xs font-mono mt-2 bg-gray-200 px-2 py-1 rounded">
                                    Eval: {evalSummary.label}
                                </span>
                            )}
                            {hintMove && (
                              <span className="text-xs font-mono mt-1 bg-yellow-100 text-yellow-800 px-2 py-1 rounded">
                                æç¤ºï¼š{hintMove.from}â†’{hintMove.to}
                              </span>
                            )}
                        </div>
                    )}
                </div>

                <div className="grid grid-cols-2 gap-3">
                    <button onClick={handleUndo} disabled={isThinking || history.length < 2} className="py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-colors disabled:opacity-50">
                        æ‚”æ£‹
                    </button>
                    <button onClick={() => { onRecordLoss && onRecordLoss(); resetGame(); }} className="py-3 bg-red-100 hover:bg-red-200 text-red-700 rounded-xl font-bold transition-colors">
                        æŠ•é™ï¼ˆè®°å…¥å¤±è´¥ï¼‰
                    </button>
                    <button
                      onClick={async () => {
                        if (!engineReady || !engineRef.current || !game || isThinking || game.turn() !== 'w') return;
                        setHintLoading(true);
                        setHintMove(null);
                        try {
                          const fen = game.fen();
                          evalPerspectiveRef.current = game.turn();
                          const best = await engineRef.current.go({ fen, level: ENGINE_LEVELS["2500"], movetimeOverride: 2500 });
                          if (best && best !== '(none)') {
                            const from = best.substring(0,2);
                            const to = best.substring(2,4);
                            setHintMove({ from, to, text: `${from}â†’${to}` });
                          }
                        } catch (e) {
                          console.error("hint error", e);
                        } finally {
                          setHintLoading(false);
                        }
                      }}
                      disabled={!engineReady || !game || isThinking || game.turn() !== 'w' || hintLoading}
                      className="py-3 col-span-2 bg-yellow-100 hover:bg-yellow-200 text-yellow-800 rounded-xl font-bold transition-colors disabled:opacity-50"
                    >
                      {hintLoading ? 'è®¡ç®—æç¤º...' : 'æç¤ºæœ€ä½³èµ°æ³•'}
                    </button>
                </div>
            </div>
          </div>
        </div>
      );
    };

    const App = () => {
      const [currentPage, setCurrentPage] = useState('hub');
      const [chessLib, setChessLib] = useState(() => window.Chess || null);
      const [importFen, setImportFen] = useState(null);
      const [unfairLosses, setUnfairLosses] = useState(0);

      useEffect(() => {
          if (!chessLib && window.Chess) {
              setChessLib(() => window.Chess);
          }
      }, []);

      const styles = `
        .font-quirky { font-family: 'Fredoka', sans-serif; }
        .game-card { transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .game-card:hover { transform: translateY(-8px) scale(1.02); box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1); }
        .square.white { background-color: #eeeed2; }
        .square.black { background-color: #769656; }
        .square.highlight { background-color: rgba(255, 255, 0, 0.5) !important; }
        .square.selected { background-color: rgba(186, 202, 68, 0.9) !important; }
        .square.last-move { background-color: rgba(245, 246, 130, 0.6) !important; }
        .chess-piece { cursor: grab; transition: transform 0.1s; }
        .chess-piece:active { cursor: grabbing; transform: scale(1.1); z-index: 50; }
      `;

      if (!chessLib) return <div className="flex h-screen items-center justify-center text-gray-500">Loading Chess Libraries...</div>;

      return (
        <div className="font-sans text-gray-900 bg-[#fdfdfd] min-h-screen">
          <style>{styles}</style>
          {currentPage === 'hub' && <Hub onSelectGame={setCurrentPage} />}
          {currentPage === 'puzzles' && (
            <PuzzleGame
              goBack={() => setCurrentPage('hub')}
              chessLib={chessLib}
              onImportToComputer={(fen) => { setImportFen(fen); setCurrentPage('computer'); }}
            />
          )}
          {currentPage === 'computer' && (
            <ComputerGame
              goBack={() => setCurrentPage('hub')}
              chessLib={chessLib}
              initialFen={importFen}
              onFenConsumed={() => setImportFen(null)}
            />
          )}
          {currentPage === 'unfair' && (
            <UnfairGame
              goBack={() => setCurrentPage('hub')}
              chessLib={chessLib}
              losses={unfairLosses}
              onRecordLoss={() => setUnfairLosses(l => l + 1)}
            />
          )}
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
